Assumption: len==73 causes crash. See:
Aug 14 05:24:05 m2 /bsd: Starting stack trace...
Aug 14 05:24:05 m2 /bsd: $d.1() at bwfm_pci_msgbuf_query_dcmd+0x2d4
Aug 14 05:24:05 m2 /bsd: bwfm_pci_msgbuf_query_dcmd() at bwfm_connect+0x604
Aug 14 05:24:05 m2 /bsd: bwfm_connect() at bwfm_newstate+0xa0
Aug 14 05:24:05 m2 /bsd: bwfm_newstate() at ieee80211_end_scan+0x378
Aug 14 05:24:05 m2 /bsd: ieee80211_end_scan() at bwfm_rx_event_cb+0x380
Aug 14 05:24:05 m2 /bsd: bwfm_rx_event_cb() at bwfm_task+0xf0
Aug 14 05:24:05 m2 /bsd: bwfm_task() at taskq_thread+0x6c
Aug 14 05:24:05 m2 /bsd: taskq_thread() at proc_trampoline+0xc
Aug 14 05:24:05 m2 /bsd: End of stack trace.
Aug 14 05:24:05 m2 /bsd: bwfm0: no timeout trans_id=111, req_buf_addr=499000, len=0xffffff809a5e4c58 *len=73
Look at bwfm_connect, some XXX:
void
bwfm_connect(struct bwfm_softc *sc)
{
        struct ieee80211com *ic = &sc->sc_ic;
        struct bwfm_ext_join_params *params;
        uint8_t buf[64];        /* XXX max WPA/RSN/WMM IE length */
        uint8_t *frm;

        /*
         * OPEN: Open or WEP or WPA/WPA2 on newer Chips/Firmware.
         * AUTO: Automatic, probably for older Chips/Firmware.
         */
        if (ic->ic_flags & IEEE80211_F_RSNON) {
                uint32_t wsec = 0;
                uint32_t wpa = 0;

                /* tell firmware to add WPA/RSN IE to (re)assoc request */
                if (ic->ic_bss->ni_rsnprotos == IEEE80211_PROTO_RSN)
                        frm = ieee80211_add_rsn(buf, ic, ic->ic_bss);
                else
                        frm = ieee80211_add_wpa(buf, ic, ic->ic_bss);
                bwfm_fwvar_var_set_data(sc, "wpaie", buf, frm - buf);

int
bwfm_fwvar_var_set_data(struct bwfm_softc *sc, char *name, void *data, size_t le
n)
{
        char *buf;
        int ret;

        buf = malloc(strlen(name) + 1 + len, M_TEMP, M_WAITOK);
        memcpy(buf, name, strlen(name) + 1);
        memcpy(buf + strlen(name) + 1, data, len);
        ret = bwfm_fwvar_cmd_set_data(sc, BWFM_C_SET_VAR,
            buf, strlen(name) + 1 + len);
        free(buf, M_TEMP, strlen(name) + 1 + len);

Where strlen("wpaie") + 1 == 6
and
bwfm_fwvar_cmd_set_data(struct bwfm_softc *sc, int cmd, void *data, size_t len)
{
        return sc->sc_proto_ops->proto_set_dcmd(sc, 0, cmd, data, len);
and
struct bwfm_proto_ops bwfm_pci_msgbuf_ops = {
        .proto_query_dcmd = bwfm_pci_msgbuf_query_dcmd,
        .proto_set_dcmd = bwfm_pci_msgbuf_set_dcmd,
and
bwfm_pci_msgbuf_set_dcmd(struct bwfm_softc *bwfm, int ifidx,
    int cmd, char *buf, size_t len)
{
        return bwfm_pci_msgbuf_query_dcmd(bwfm, ifidx, cmd, buf, &len);
and finally
bwfm_pci_msgbuf_query_dcmd(struct bwfm_softc *bwfm, int ifidx,
    int cmd, char *buf, size_t *len)
{
...
if (*len == 73 || ctl->transid == 68 || ctl->transid == 69 || ctl->transid == 70
)
db_stack_dump();

=> *len = 6 + 67 => uint8_t buf[64] < 6 ???!!!11

commit 63498aa87cbe8e5ed9cdbbb7cc4275894563b8e1
Author: patrick <patrick@openbsd.org>
Date:   Sat Oct 21 20:43:03 2017 +0000

    Even though letting the firmware handle the handshake is nice from
    a user perspective, it's rather horrible from a security perspective.

maybe.

Index: dev/ic/bwfm.c
===================================================================
RCS file: /cvs/src/sys/dev/ic/bwfm.c,v
diff -u -p -r1.111 bwfm.c
--- dev/ic/bwfm.c	19 Feb 2024 21:23:02 -0000	1.111
+++ dev/ic/bwfm.c	14 Aug 2024 04:00:49 -0000
@@ -1984,7 +1987,7 @@ bwfm_connect(struct bwfm_softc *sc)
 {
 	struct ieee80211com *ic = &sc->sc_ic;
 	struct bwfm_ext_join_params *params;
-	uint8_t buf[64];	/* XXX max WPA/RSN/WMM IE length */
+	uint8_t buf[2*64];	/* XXX max WPA/RSN/WMM IE length */
 	uint8_t *frm;
 
 	/*
