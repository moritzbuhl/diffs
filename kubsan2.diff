Fix KUBSAN by adding invalid builtin detection, as needed by our current clang.
ok anton@
Index: ./share/man/man4/kubsan.4
===================================================================
RCS file: /cvs/src/share/man/man4/kubsan.4,v
diff -u -p -r1.3 kubsan.4
--- ./share/man/man4/kubsan.4	24 May 2019 18:53:25 -0000	1.3
+++ ./share/man/man4/kubsan.4	6 Sep 2024 12:07:33 -0000
@@ -66,6 +72,8 @@ Passing
 .Dv NULL
 as the value for a function argument annotated with
 .Dv __nonnull__ .
+.It Invalid builtin
+Passing zero to a compiler builtin where not allowed.
 .It Invalid load
 Loading a value that cannot be represented by the destination type.
 .It Type mismatch
Index: sys/kern/subr_kubsan.c
===================================================================
RCS file: /cvs/src/sys/kern/subr_kubsan.c,v
diff -u -p -r1.12 subr_kubsan.c
--- sys/kern/subr_kubsan.c	6 Nov 2019 19:16:48 -0000	1.12
+++ sys/kern/subr_kubsan.c	6 Sep 2024 12:07:33 -0000
@@ -38,6 +38,7 @@
 struct kubsan_report {
 	enum {
 		KUBSAN_FLOAT_CAST_OVERFLOW,
+		KUBSAN_INVALID_BUILTIN,
 		KUBSAN_INVALID_VALUE,
 		KUBSAN_NEGATE_OVERFLOW,
 		KUBSAN_NONNULL_ARG,
@@ -58,6 +59,10 @@ struct kubsan_report {
 		} v_float_cast_overflow;
 
 		struct {
+			const struct invalid_builtin_data *v_data;
+		} v_invalid_builtin;
+
+		struct {
 			const struct invalid_value_data *v_data;
 			unsigned long v_val;
 		} v_invalid_value;
@@ -102,6 +107,7 @@ struct kubsan_report {
 	} kr_u;
 };
 #define kr_float_cast_overflow		kr_u.v_float_cast_overflow
+#define kr_invalid_builtin		kr_u.v_invalid_builtin
 #define kr_invalid_value		kr_u.v_invalid_value
 #define kr_negate_overflow		kr_u.v_negate_overflow
 #define kr_nonnull_arg			kr_u.v_nonnull_arg
@@ -129,6 +135,11 @@ struct float_cast_overflow_data {
 	struct type_descriptor *d_ttype;	/* to type */
 };
 
+struct invalid_builtin_data {
+	struct source_location d_src;
+	uint8_t d_kind;
+};
+
 struct invalid_value_data {
 	struct source_location d_src;
 	struct type_descriptor *d_type;
@@ -265,6 +276,18 @@ __ubsan_handle_float_cast_overflow(struc
 }
 
 void
+__ubsan_handle_invalid_builtin(struct invalid_builtin_data *data)
+{
+	struct kubsan_report kr = {
+		.kr_type		= KUBSAN_INVALID_VALUE,
+		.kr_src			= &data->d_src,
+		.kr_invalid_builtin	= { data },
+	};
+
+	kubsan_defer_report(&kr);
+}
+
+void
 __ubsan_handle_load_invalid_value(struct invalid_value_data *data,
     unsigned long val)
 {
@@ -559,6 +582,16 @@ again:
 			    "of representable values of type %s\n",
 			    bloc, blhs, data->d_ftype->t_name,
 			    data->d_ttype->t_name);
+			break;
+		}
+
+		case KUBSAN_INVALID_BUILTIN: {
+			const struct invalid_builtin_data *data =
+			    kr->kr_invalid_builtin.v_data;
+
+			printf("kubsan: %s: invalid builtin: passing zero to "
+			    "%s, which is not a valid argument\n",
+			    bloc, kubsan_kind(data->d_kind));
 			break;
 		}
 
