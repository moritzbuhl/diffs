Index: arch/amd64/amd64/kasan.c
===================================================================
RCS file: arch/amd64/amd64/kasan.c
diff -N arch/amd64/amd64/kasan.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ arch/amd64/amd64/kasan.c	25 Apr 2023 20:51:34 -0000
@@ -0,0 +1,98 @@
+/*	$OpenBSD: kasan.c $	*/
+
+#include <sys/mman.h>
+
+#include <uvm/uvm.h>
+
+#include <machine/cpu.h>
+#include <machine/pmap.h>
+#include <machine/segments.h>
+#include <machine/vmmvar.h>
+
+static paddr_t
+get_physpage(void)
+{
+	struct vm_page *ptp;
+	struct pmap *kpm = pmap_kernel();
+	paddr_t paddr;
+
+	ptp = uvm_pagealloc(NULL, 0, NULL, UVM_PGA_USERESERVE | UVM_PGA_ZERO);
+	if (ptp == NULL)
+		panic("%s: out of memory", __func__);
+
+	atomic_clearbits_int(&ptp->pg_flags, PG_BUSY);
+	ptp->wire_count = 1;
+	paddr = VM_PAGE_TO_PHYS(ptp);
+
+	kpm->pm_stats.resident_count++;
+
+	return (paddr);
+}
+
+void
+kasan_shadow_map_page(vaddr_t va)
+{
+	paddr_t pg;
+
+	if (!pmap_valid_entry(L4_BASE[pl4_i(va)])) {
+		pg = get_physpage();
+		L4_BASE[pl4_i(va)] = pg | PG_KW | pg_nx | PG_V;
+i	}
+	if (!pmap_valid_entry(L3_BASE[pl3_i(va)])) {
+		pg = get_physpage();
+		L3_BASE[pl3_i(va)] = pg | PG_KW | pg_nx | PG_V;
+	}
+	if (!pmap_valid_entry(L2_BASE[pl2_i(va)])) {
+		pg = get_physpage();
+		L2_BASE[pl2_i(va)] = pg | PG_KW | pg_nx | PG_V;
+	}
+	if (!pmap_valid_entry(L1_BASE[pl1_i(va)])) {
+		pg = get_physpage();
+		L1_BASE[pl1_i(va)] = pg | PG_KW | pg_g_kern | pg_nx | PG_V;
+	}
+}
+
+/*
+ * Allocate the necessary stuff in the shadow, so that we can monitor the
+ * passed area.
+ */
+void
+kasan_shadow_map(vaddr_t addr, size_t size)
+{
+	size_t sz, npages, i;
+	vaddr_t va;
+
+	va = (vaddr_t)kasan_addr_to_shad(addr);
+	sz = roundup(size, KASAN_SHADOW_SCALE_SIZE) / KASAN_SHADOW_SCALE_SIZE;
+	va = rounddown(va, PAGE_SIZE);
+	npages = roundup(sz, PAGE_SIZE) / PAGE_SIZE;
+
+	KASSERT(va >= KASAN_SHADOW_START && va < KASAN_SHADOW_END);
+
+	for (i = 0; i < npages; i++) {
+		kasan_shadow_map_page(va + i * PAGE_SIZE);
+	}
+}
+
+void
+kasan_ctors(void)
+{
+	extern uint64_t __CTOR_LIST__, __CTOR_END__;
+	size_t nentries, i;
+	uint64_t *ptr;
+
+	nentries = ((size_t)&__CTOR_END__ - (size_t)&__CTOR_LIST__) /
+	    sizeof(uintptr_t);
+
+	ptr = &__CTOR_LIST__;
+	for (i = 0; i < nentries; i++) {
+		void (*func)(void);
+
+		func = (void *)(*ptr);
+		(*func)();
+
+		ptr++;
+	}
+}
+
+
Index: arch/amd64/conf/files.amd64
===================================================================
RCS file: /cvs/src/sys/arch/amd64/conf/files.amd64,v
retrieving revision 1.107
diff -u -p -r1.107 files.amd64
--- arch/amd64/conf/files.amd64	14 Jan 2023 12:11:10 -0000	1.107
+++ arch/amd64/conf/files.amd64	25 Apr 2023 19:36:43 -0000
@@ -10,6 +10,7 @@ file	arch/amd64/amd64/gdt.c			multiproce
 file	arch/amd64/amd64/machdep.c
 file	arch/amd64/amd64/hibernate_machdep.c	hibernate
 file	arch/amd64/amd64/identcpu.c
+file	arch/amd64/amd64/kasan.c		kasan
 file	arch/amd64/amd64/tsc.c
 file	arch/amd64/amd64/via.c
 file	arch/amd64/amd64/locore.S
Index: arch/amd64/conf/ld.script
===================================================================
RCS file: /cvs/src/sys/arch/amd64/conf/ld.script,v
retrieving revision 1.19
diff -u -p -r1.19 ld.script
--- arch/amd64/conf/ld.script	7 Nov 2022 01:41:57 -0000	1.19
+++ arch/amd64/conf/ld.script	25 Apr 2023 20:13:16 -0000
@@ -85,6 +85,10 @@ SECTIONS
 	{
 		__rodata_start = ABSOLUTE(.);
 		*(.rodata .rodata.*)
+		. = ALIGN(64);
+		__CTOR_LIST__ = .;
+		*(.ctors)
+		__CTOR_END__ = .;
 		. = ALIGN(8);
 		__nofault_start = ABSOLUTE(.);
 		*(.nofault.*) *(.nofault)
Index: arch/amd64/include/kasan.h
===================================================================
RCS file: arch/amd64/include/kasan.h
diff -N arch/amd64/include/kasan.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ arch/amd64/include/kasan.h	25 Apr 2023 20:50:37 -0000
@@ -0,0 +1,9 @@
+/*	$OpenBSD: kasan.h $	*/
+
+#ifndef _MACHINE_KASAN_H_
+#define _MACHINE_KASAN_H_
+
+void	kasan_shadow_map(vaddr_t);
+void	kasan_ctors(void);
+
+#endif /* !_MACHINE_KASAN_H_ */
Index: arch/amd64/include/pmap.h
===================================================================
RCS file: /cvs/src/sys/arch/amd64/include/pmap.h,v
retrieving revision 1.86
diff -u -p -r1.86 pmap.h
--- arch/amd64/include/pmap.h	13 Apr 2023 15:23:21 -0000	1.86
+++ arch/amd64/include/pmap.h	25 Apr 2023 20:02:02 -0000
@@ -145,11 +145,13 @@
 #define NUM_L4_SLOT_DIRECT	4
 #define L4_SLOT_DIRECT		(L4_SLOT_KERNBASE - NUM_L4_SLOT_DIRECT)
 #define L4_SLOT_EARLY		(L4_SLOT_DIRECT - 1)
+#define L4_SLOT_KASAN		(L4_SLOT_DIRECT - 2)
 
 #define PDIR_SLOT_KERN		L4_SLOT_KERN
 #define PDIR_SLOT_PTE		L4_SLOT_PTE
 #define PDIR_SLOT_DIRECT	L4_SLOT_DIRECT
 #define PDIR_SLOT_EARLY		L4_SLOT_EARLY
+#define PDIR_SLOT_KASAN		L4_SLOT_KASAN
 
 /*
  * the following defines give the virtual addresses of various MMU
Index: conf/files
===================================================================
RCS file: /cvs/src/sys/conf/files,v
retrieving revision 1.723
diff -u -p -r1.723 files
--- conf/files	4 Apr 2023 00:38:37 -0000	1.723
+++ conf/files	25 Apr 2023 19:35:36 -0000
@@ -732,6 +732,7 @@ file kern/subr_evcount.c
 file kern/subr_extent.c
 file kern/subr_suspend.c		suspend
 file kern/subr_hibernate.c		hibernate
+file kern/subr_kasan.c			kasan
 file kern/subr_kubsan.c			kubsan
 file kern/subr_log.c
 file kern/subr_percpu.c
Index: kern/subr_kasan.c
===================================================================
RCS file: kern/subr_kasan.c
diff -N kern/subr_kasan.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ kern/subr_kasan.c	25 Apr 2023 20:50:34 -0000
@@ -0,0 +1,120 @@
+/*	$OpenBSD: subr_kasan.c $	*/
+
+#include <sys/param.h>
+#include <sys/kasan.h>
+#include <sys/proc.h>
+#include <sys/tree.h>
+#include <sys/types.h>
+#include <sys/systm.h>
+
+#include <machine/kasan.h>
+#include <machine/cpu.h>
+#include <machine/segments.h>
+
+#include <uvm/uvm_extern.h>
+
+void kasan_init(void);
+
+static int kasan_enabled = false;
+
+static inline int8_t *
+kasan_addr_to_shad(vaddr_t va)
+{
+	return (char *)(KASAN_SHADOW_START +
+	    ((va - VM_MIN_KERNEL_ADDRESS) >> KASAN_SHADOW_SCALE_SHIFT));
+}
+
+static int
+kasan_unsupported(vaddr_t addr)
+{
+	return (addr >= VM_MIN_KERNEL_ADDRESS &&
+	    addr < VM_MAX_KERNEL_ADDRESS);
+}
+
+/*
+ * Create the shadow mapping. We don't create the 'User' area, because we
+ * exclude it from the monitoring. The 'Main' area is created dynamically
+ * in pmap_growkernel.
+ */
+void
+kasan_init(void)
+{
+	kasan_enabled = 1;
+
+	/* Call the ASAN constructors. */
+	kasan_ctors();
+}
+
+static void
+kasan_report(vaddr_t addr, size_t size, bool write, vaddr_t rip)
+{
+	printf("KASAN: unregistered access at 0x%lx: "
+	    "%s of %lu byte%s from 0x%lx\n", rip,
+	    (write ? "write" : "read"), size, (size > 1 ? "s" : ""), addr);
+}
+
+static void
+kasan_shadow_fill(vaddr_t addr, size_t size, uint8_t val)
+{
+	char *shad;
+
+	if (!kasan_enabled)
+		return;
+	if (size == 0)
+		return;
+	if (kasan_unsupported(addr))
+		return;
+
+	KASSERT(addr % KASAN_SHADOW_SCALE_SIZE == 0);
+	KASSERT(size % KASAN_SHADOW_SCALE_SIZE == 0);
+
+	shad = kasan_addr_to_shad(addr);
+	size = size >> KASAN_SHADOW_SCALE_SHIFT;
+
+	__builtin_memset(shad, val, size);
+}
+
+static inline void
+kasan_shadow_1byte_markvalid(vaddr_t addr)
+{
+	char *byte = kasan_addr_to_shad(addr);
+	char last = (addr & KASAN_SHADOW_MASK) + 1;
+
+	*byte = last;
+}
+
+void
+kasan_add_redzone(size_t *size)
+{
+	*size = roundup(*size, KASAN_SHADOW_SCALE_SIZE);
+	*size += KASAN_SHADOW_SCALE_SIZE;
+}
+
+static void
+kasan_markmem(vaddr_t addr, size_t size, int valid)
+{
+	size_t i;
+
+	KASSERT(addr % KASAN_SHADOW_SCALE_SIZE == 0);
+
+	if (valid) {
+		for (i = 0; i < size; i++)
+			kasan_shadow_1byte_markvalid(addr + i);
+	} else {
+		KASSERT(size % KASAN_SHADOW_SCALE_SIZE == 0);
+		kasan_shadow_fill(addr, size, KASAN_MEMORY_REDZONE);
+	}
+}
+
+void
+kasan_alloc(vaddr_t addr, size_t size, size_t sz_with_redz)
+{
+	kasan_markmem(addr, sz_with_redz, false);
+	kasan_markmem(addr, size, true);
+}
+
+void
+kasan_free(vaddr_t addr, size_t sz_with_redz)
+{
+	kasan_markmem(addr, sz_with_redz, true);
+}
Index: sys/kasan.h
===================================================================
RCS file: sys/kasan.h
diff -N sys/kasan.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sys/kasan.h	25 Apr 2023 20:50:28 -0000
@@ -0,0 +1,27 @@
+/*	$OpenBSD: kasan.h $	*/
+
+#ifndef _SYS_KASAN_H_
+#define _SYS_KASAN_H_
+
+#define KASAN_SHADOW_SCALE_SHIFT	3
+#define KASAN_SHADOW_SCALE_SIZE		(1UL << KASAN_SHADOW_SCALE_SHIFT)
+#define KASAN_SHADOW_MASK		(KASAN_SHADOW_SCALE_SIZE - 1)
+
+#define KASAN_SHADOW_SIZE	(VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS)
+#define KASAN_SHADOW_START	(VA_SIGN_NEG((L4_SLOT_KASAN * NBPD_L4)))
+#define KASAN_SHADOW_END	(KASAN_SHADOW_START + KASAN_SHADOW_SIZE)
+
+#define __RET_ADDR	(unsigned long)__builtin_return_address(0)
+
+/* Our redzone values. */
+#define KASAN_GLOBAL_REDZONE	0xFA
+#define KASAN_MEMORY_REDZONE	0xFB
+
+/* Stack redzone shadow values. Part of the compiler ABI. */
+#define KASAN_STACK_LEFT	0xF1
+#define KASAN_STACK_MID		0xF2
+#define KASAN_STACK_RIGHT	0xF3
+#define KASAN_STACK_PARTIAL	0xF4
+#define KASAN_USE_AFTER_SCOPE	0xF8
+
+#endif /* !_SYS_KASAN_H_ */
