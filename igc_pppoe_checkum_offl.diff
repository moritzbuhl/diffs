diff --git sys/dev/pci/if_igc.c sys/dev/pci/if_igc.c
index 53bda8d1147..d2e4bdb391b 100644
--- sys/dev/pci/if_igc.c
+++ sys/dev/pci/if_igc.c
@@ -2069,7 +2069,13 @@ igc_tx_ctx_setup(struct tx_ring *txr, struct mbuf *mp, int prod,
 
 	ether_extract_headers(mp, &ext);
 
-	vlan_macip_lens |= (sizeof(*ext.eh) << IGC_ADVTXD_MACLEN_SHIFT);
+	if (ext.eppph) {
+	        vlan_macip_lens |=
+	            (sizeof(*ext.eppph) << IGC_ADVTXD_MACLEN_SHIFT);
+	} else {
+	        vlan_macip_lens |=
+	            (sizeof(*ext.eh) << IGC_ADVTXD_MACLEN_SHIFT);
+	}
 
 	if (ext.ip4) {
 		type_tucmd_mlhl |= IGC_ADVTXD_TUCMD_IPV4;
diff --git sys/net/if_ethersubr.c sys/net/if_ethersubr.c
index a7c6d5b1efe..c6618e843b1 100644
--- sys/net/if_ethersubr.c
+++ sys/net/if_ethersubr.c
@@ -94,6 +94,7 @@ didn't get a copy, you may request one from <license@ipv6.nrl.navy.mil>.
 #include <net/if_dl.h>
 #include <net/if_media.h>
 #include <net/if_types.h>
+#include <net/ppp_defs.h>
 
 #include <netinet/in.h>
 #include <netinet/if_ether.h>
@@ -1120,6 +1121,28 @@ ether_extract_headers(struct mbuf *m0, struct ether_extracted *ext)
 	}
 #endif
 
+	if (ether_type == ETHERTYPE_PPPOE) {
+		hlen = sizeof(struct ether_pppoe_header);
+		if (m0->m_len < hlen)
+			return;
+
+		ext->eppph = mtod(m0, struct ether_pppoe_header *);
+
+		if (ext->eppph->eppp_code != 0)
+			return;
+
+		switch (ntohs(ext->eppph->eppp_protocol)) { /* XXX */
+		case PPP_IP:
+			ether_type = ETHERTYPE_IP;
+			break;
+		case PPP_IPV6:
+			ether_type = ETHERTYPE_IPV6;
+			break;
+		default:
+			return;
+		}
+	}
+
 	switch (ether_type) {
 	case ETHERTYPE_IP:
 		m = m_getptr(m0, hlen, &hoff);
diff --git sys/netinet/if_ether.h sys/netinet/if_ether.h
index f4240e8c4ec..717adeaaa7b 100644
--- sys/netinet/if_ether.h
+++ sys/netinet/if_ether.h
@@ -105,6 +105,21 @@ struct  ether_vlan_header {
 
 #define EVL_ENCAPLEN    4       /* length in octets of encapsulation */
 
+/*
+ * PPPoE headers.
+ */
+
+struct  ether_pppoe_header {
+	u_char  eppp_dhost[ETHER_ADDR_LEN];
+	u_char  eppp_shost[ETHER_ADDR_LEN];
+	u_int16_t eppp_encap_proto;
+	u_int8_t  eppp_vertype;
+	u_int8_t  eppp_code;
+	u_int16_t eppp_session_id;
+	u_int16_t eppp_length;
+	u_int16_t eppp_protocol;
+} __packed;
+
 #include <net/ethertypes.h>
 
 #define	ETHER_IS_MULTICAST(addr) (*(addr) & 0x01) /* is address mcast/bcast? */
@@ -303,6 +318,7 @@ void		ether_e64_to_addr(struct ether_addr *, uint64_t);
 struct ether_extracted {
 	struct ether_header		*eh;
 	struct ether_vlan_header	*evh;
+	struct ether_pppoe_header	*eppph;
 	struct ip			*ip4;
 	struct ip6_hdr			*ip6;
 	struct tcphdr			*tcp;
