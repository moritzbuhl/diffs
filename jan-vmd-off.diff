diff --git a/sys/dev/pv/if_vio.c b/sys/dev/pv/if_vio.c
index db399e7190d..1df228544c3 100644
--- a/sys/dev/pv/if_vio.c
+++ b/sys/dev/pv/if_vio.c
@@ -61,134 +61,7 @@
 #define DPRINTF(x...)
 #endif
 
-/*
- * if_vioreg.h:
- */
-/* Configuration registers */
-#define VIRTIO_NET_CONFIG_MAC		0 /* 8bit x 6byte */
-#define VIRTIO_NET_CONFIG_STATUS	6 /* 16bit */
-
-/* Feature bits */
-#define VIRTIO_NET_F_CSUM			(1ULL<<0)
-#define VIRTIO_NET_F_GUEST_CSUM			(1ULL<<1)
-#define VIRTIO_NET_F_CTRL_GUEST_OFFLOADS        (1ULL<<2)
-#define VIRTIO_NET_F_MTU                        (1ULL<<3)
-#define VIRTIO_NET_F_MAC			(1ULL<<5)
-#define VIRTIO_NET_F_GSO			(1ULL<<6)
-#define VIRTIO_NET_F_GUEST_TSO4			(1ULL<<7)
-#define VIRTIO_NET_F_GUEST_TSO6			(1ULL<<8)
-#define VIRTIO_NET_F_GUEST_ECN			(1ULL<<9)
-#define VIRTIO_NET_F_GUEST_UFO			(1ULL<<10)
-#define VIRTIO_NET_F_HOST_TSO4			(1ULL<<11)
-#define VIRTIO_NET_F_HOST_TSO6			(1ULL<<12)
-#define VIRTIO_NET_F_HOST_ECN			(1ULL<<13)
-#define VIRTIO_NET_F_HOST_UFO			(1ULL<<14)
-#define VIRTIO_NET_F_MRG_RXBUF			(1ULL<<15)
-#define VIRTIO_NET_F_STATUS			(1ULL<<16)
-#define VIRTIO_NET_F_CTRL_VQ			(1ULL<<17)
-#define VIRTIO_NET_F_CTRL_RX			(1ULL<<18)
-#define VIRTIO_NET_F_CTRL_VLAN			(1ULL<<19)
-#define VIRTIO_NET_F_CTRL_RX_EXTRA		(1ULL<<20)
-#define VIRTIO_NET_F_GUEST_ANNOUNCE		(1ULL<<21)
-#define VIRTIO_NET_F_MQ				(1ULL<<22)
-#define VIRTIO_NET_F_CTRL_MAC_ADDR		(1ULL<<23)
-
-/*
- * Config(8) flags. The lowest byte is reserved for generic virtio stuff.
- */
-
-/* Workaround for vlan related bug in qemu < version 2.0 */
-#define CONFFLAG_QEMU_VLAN_BUG		(1<<8)
-
-static const struct virtio_feature_name virtio_net_feature_names[] = {
-#if VIRTIO_DEBUG
-	{ VIRTIO_NET_F_CSUM,			"CSum" },
-	{ VIRTIO_NET_F_GUEST_CSUM,		"GuestCSum" },
-	{ VIRTIO_NET_F_CTRL_GUEST_OFFLOADS,	"CtrlGuestOffl" },
-	{ VIRTIO_NET_F_MTU,			"MTU", },
-	{ VIRTIO_NET_F_MAC,			"MAC" },
-	{ VIRTIO_NET_F_GSO,			"GSO" },
-	{ VIRTIO_NET_F_GUEST_TSO4,		"GuestTSO4" },
-	{ VIRTIO_NET_F_GUEST_TSO6,		"GuestTSO6" },
-	{ VIRTIO_NET_F_GUEST_ECN,		"GuestECN" },
-	{ VIRTIO_NET_F_GUEST_UFO,		"GuestUFO" },
-	{ VIRTIO_NET_F_HOST_TSO4,		"HostTSO4" },
-	{ VIRTIO_NET_F_HOST_TSO6,		"HostTSO6" },
-	{ VIRTIO_NET_F_HOST_ECN,		"HostECN" },
-	{ VIRTIO_NET_F_HOST_UFO,		"HostUFO" },
-	{ VIRTIO_NET_F_MRG_RXBUF,		"MrgRXBuf" },
-	{ VIRTIO_NET_F_STATUS,			"Status" },
-	{ VIRTIO_NET_F_CTRL_VQ,			"CtrlVQ" },
-	{ VIRTIO_NET_F_CTRL_RX,			"CtrlRX" },
-	{ VIRTIO_NET_F_CTRL_VLAN,		"CtrlVLAN" },
-	{ VIRTIO_NET_F_CTRL_RX_EXTRA,		"CtrlRXExtra" },
-	{ VIRTIO_NET_F_GUEST_ANNOUNCE,		"GuestAnnounce" },
-	{ VIRTIO_NET_F_MQ,			"MQ" },
-	{ VIRTIO_NET_F_CTRL_MAC_ADDR,		"CtrlMAC" },
-#endif
-	{ 0,				NULL }
-};
-
-/* Status */
-#define VIRTIO_NET_S_LINK_UP	1
-
-/* Packet header structure */
-struct virtio_net_hdr {
-	uint8_t		flags;
-	uint8_t		gso_type;
-	uint16_t	hdr_len;
-	uint16_t	gso_size;
-	uint16_t	csum_start;
-	uint16_t	csum_offset;
-
-	/* only present if VIRTIO_NET_F_MRG_RXBUF is negotiated */
-	uint16_t	num_buffers;
-} __packed;
-
-#define VIRTIO_NET_HDR_F_NEEDS_CSUM	1 /* flags */
-#define VIRTIO_NET_HDR_F_DATA_VALID	2 /* flags */
-#define VIRTIO_NET_HDR_GSO_NONE		0 /* gso_type */
-#define VIRTIO_NET_HDR_GSO_TCPV4	1 /* gso_type */
-#define VIRTIO_NET_HDR_GSO_UDP		3 /* gso_type */
-#define VIRTIO_NET_HDR_GSO_TCPV6	4 /* gso_type */
-#define VIRTIO_NET_HDR_GSO_ECN		0x80 /* gso_type, |'ed */
-
-#define VIRTIO_NET_MAX_GSO_LEN		(65536+ETHER_HDR_LEN)
-
-/* Control virtqueue */
-struct virtio_net_ctrl_cmd {
-	uint8_t	class;
-	uint8_t	command;
-} __packed;
-#define VIRTIO_NET_CTRL_RX		0
-# define VIRTIO_NET_CTRL_RX_PROMISC	0
-# define VIRTIO_NET_CTRL_RX_ALLMULTI	1
-
-#define VIRTIO_NET_CTRL_MAC		1
-# define VIRTIO_NET_CTRL_MAC_TABLE_SET	0
-
-#define VIRTIO_NET_CTRL_VLAN		2
-# define VIRTIO_NET_CTRL_VLAN_ADD	0
-# define VIRTIO_NET_CTRL_VLAN_DEL	1
-
-struct virtio_net_ctrl_status {
-	uint8_t	ack;
-} __packed;
-#define VIRTIO_NET_OK			0
-#define VIRTIO_NET_ERR			1
-
-struct virtio_net_ctrl_rx {
-	uint8_t	onoff;
-} __packed;
-
-struct virtio_net_ctrl_mac_tbl {
-	uint32_t nentries;
-	uint8_t macs[][ETHER_ADDR_LEN];
-} __packed;
-
-struct virtio_net_ctrl_vlan {
-	uint16_t id;
-} __packed;
+#include "if_vioreg.h"
 
 /*
  * if_viovar.h:
diff --git a/sys/dev/pv/if_vioreg.h b/sys/dev/pv/if_vioreg.h
new file mode 100644
index 00000000000..eda2e8077d4
--- /dev/null
+++ b/sys/dev/pv/if_vioreg.h
@@ -0,0 +1,165 @@
+/*	$OpenBSD: if_vio.c,v 1.26 2023/11/10 15:51:24 bluhm Exp $	*/
+
+/*
+ * Copyright (c) 2012 Stefan Fritsch, Alexander Fiveg.
+ * Copyright (c) 2010 Minoura Makoto.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * if_vioreg.h:
+ */
+/* Configuration registers */
+#define VIRTIO_NET_CONFIG_MAC		0 /* 8bit x 6byte */
+#define VIRTIO_NET_CONFIG_STATUS	6 /* 16bit */
+
+/* Feature bits */
+#define VIRTIO_NET_F_CSUM			(1ULL<<0)
+#define VIRTIO_NET_F_GUEST_CSUM			(1ULL<<1)
+#define VIRTIO_NET_F_CTRL_GUEST_OFFLOADS        (1ULL<<2)
+#define VIRTIO_NET_F_MTU                        (1ULL<<3)
+#define VIRTIO_NET_F_MAC			(1ULL<<5)
+#define VIRTIO_NET_F_GSO			(1ULL<<6)
+#define VIRTIO_NET_F_GUEST_TSO4			(1ULL<<7)
+#define VIRTIO_NET_F_GUEST_TSO6			(1ULL<<8)
+#define VIRTIO_NET_F_GUEST_ECN			(1ULL<<9)
+#define VIRTIO_NET_F_GUEST_UFO			(1ULL<<10)
+#define VIRTIO_NET_F_HOST_TSO4			(1ULL<<11)
+#define VIRTIO_NET_F_HOST_TSO6			(1ULL<<12)
+#define VIRTIO_NET_F_HOST_ECN			(1ULL<<13)
+#define VIRTIO_NET_F_HOST_UFO			(1ULL<<14)
+#define VIRTIO_NET_F_MRG_RXBUF			(1ULL<<15)
+#define VIRTIO_NET_F_STATUS			(1ULL<<16)
+#define VIRTIO_NET_F_CTRL_VQ			(1ULL<<17)
+#define VIRTIO_NET_F_CTRL_RX			(1ULL<<18)
+#define VIRTIO_NET_F_CTRL_VLAN			(1ULL<<19)
+#define VIRTIO_NET_F_CTRL_RX_EXTRA		(1ULL<<20)
+#define VIRTIO_NET_F_GUEST_ANNOUNCE		(1ULL<<21)
+#define VIRTIO_NET_F_MQ				(1ULL<<22)
+#define VIRTIO_NET_F_CTRL_MAC_ADDR		(1ULL<<23)
+
+/*
+ * Config(8) flags. The lowest byte is reserved for generic virtio stuff.
+ */
+
+/* Workaround for vlan related bug in qemu < version 2.0 */
+#define CONFFLAG_QEMU_VLAN_BUG		(1<<8)
+
+static const struct virtio_feature_name virtio_net_feature_names[] = {
+#if VIRTIO_DEBUG
+	{ VIRTIO_NET_F_CSUM,			"CSum" },
+	{ VIRTIO_NET_F_GUEST_CSUM,		"GuestCSum" },
+	{ VIRTIO_NET_F_CTRL_GUEST_OFFLOADS,	"CtrlGuestOffl" },
+	{ VIRTIO_NET_F_MTU,			"MTU", },
+	{ VIRTIO_NET_F_MAC,			"MAC" },
+	{ VIRTIO_NET_F_GSO,			"GSO" },
+	{ VIRTIO_NET_F_GUEST_TSO4,		"GuestTSO4" },
+	{ VIRTIO_NET_F_GUEST_TSO6,		"GuestTSO6" },
+	{ VIRTIO_NET_F_GUEST_ECN,		"GuestECN" },
+	{ VIRTIO_NET_F_GUEST_UFO,		"GuestUFO" },
+	{ VIRTIO_NET_F_HOST_TSO4,		"HostTSO4" },
+	{ VIRTIO_NET_F_HOST_TSO6,		"HostTSO6" },
+	{ VIRTIO_NET_F_HOST_ECN,		"HostECN" },
+	{ VIRTIO_NET_F_HOST_UFO,		"HostUFO" },
+	{ VIRTIO_NET_F_MRG_RXBUF,		"MrgRXBuf" },
+	{ VIRTIO_NET_F_STATUS,			"Status" },
+	{ VIRTIO_NET_F_CTRL_VQ,			"CtrlVQ" },
+	{ VIRTIO_NET_F_CTRL_RX,			"CtrlRX" },
+	{ VIRTIO_NET_F_CTRL_VLAN,		"CtrlVLAN" },
+	{ VIRTIO_NET_F_CTRL_RX_EXTRA,		"CtrlRXExtra" },
+	{ VIRTIO_NET_F_GUEST_ANNOUNCE,		"GuestAnnounce" },
+	{ VIRTIO_NET_F_MQ,			"MQ" },
+	{ VIRTIO_NET_F_CTRL_MAC_ADDR,		"CtrlMAC" },
+#endif
+	{ 0,				NULL }
+};
+
+/* Status */
+#define VIRTIO_NET_S_LINK_UP	1
+
+/* Packet header structure */
+struct virtio_net_hdr {
+	uint8_t		flags;
+	uint8_t		gso_type;
+	uint16_t	hdr_len;
+	uint16_t	gso_size;
+	uint16_t	csum_start;
+	uint16_t	csum_offset;
+
+	/* only present if VIRTIO_NET_F_MRG_RXBUF is negotiated */
+	uint16_t	num_buffers;
+} __packed;
+
+struct virtio_net_hdr_legacy {
+	uint8_t		flags;
+	uint8_t		gso_type;
+	uint16_t	hdr_len;
+	uint16_t	gso_size;
+	uint16_t	csum_start;
+	uint16_t	csum_offset;
+} __packed;
+
+#define VIRTIO_NET_HDR_F_NEEDS_CSUM	1 /* flags */
+#define VIRTIO_NET_HDR_F_DATA_VALID	2 /* flags */
+#define VIRTIO_NET_HDR_GSO_NONE		0 /* gso_type */
+#define VIRTIO_NET_HDR_GSO_TCPV4	1 /* gso_type */
+#define VIRTIO_NET_HDR_GSO_UDP		3 /* gso_type */
+#define VIRTIO_NET_HDR_GSO_TCPV6	4 /* gso_type */
+#define VIRTIO_NET_HDR_GSO_ECN		0x80 /* gso_type, |'ed */
+
+#define VIRTIO_NET_MAX_GSO_LEN		(65536+ETHER_HDR_LEN)
+
+/* Control virtqueue */
+struct virtio_net_ctrl_cmd {
+	uint8_t	class;
+	uint8_t	command;
+} __packed;
+#define VIRTIO_NET_CTRL_RX		0
+# define VIRTIO_NET_CTRL_RX_PROMISC	0
+# define VIRTIO_NET_CTRL_RX_ALLMULTI	1
+
+#define VIRTIO_NET_CTRL_MAC		1
+# define VIRTIO_NET_CTRL_MAC_TABLE_SET	0
+
+#define VIRTIO_NET_CTRL_VLAN		2
+# define VIRTIO_NET_CTRL_VLAN_ADD	0
+# define VIRTIO_NET_CTRL_VLAN_DEL	1
+
+struct virtio_net_ctrl_status {
+	uint8_t	ack;
+} __packed;
+#define VIRTIO_NET_OK			0
+#define VIRTIO_NET_ERR			1
+
+struct virtio_net_ctrl_rx {
+	uint8_t	onoff;
+} __packed;
+
+struct virtio_net_ctrl_mac_tbl {
+	uint32_t nentries;
+	uint8_t macs[][ETHER_ADDR_LEN];
+} __packed;
+
+struct virtio_net_ctrl_vlan {
+	uint16_t id;
+} __packed;
diff --git a/sys/net/if_tun.c b/sys/net/if_tun.c
index 246a3009673..b940510bf53 100644
--- a/sys/net/if_tun.c
+++ b/sys/net/if_tun.c
@@ -63,8 +63,15 @@
 #include <net/rtable.h>
 
 #include <netinet/in.h>
+#include <netinet/ip.h>
+#include <netinet/ip6.h>
+#include <netinet/tcp.h>
+#include <netinet/udp.h>
 #include <netinet/if_ether.h>
 
+#include <dev/pv/virtiovar.h>
+#include <dev/pv/if_vioreg.h>
+
 #include "bpfilter.h"
 #if NBPFILTER > 0
 #include <net/bpf.h>
@@ -92,6 +99,7 @@ struct tun_softc {
 	dev_t			sc_dev;
 	struct refcnt		sc_refs;
 	unsigned int		sc_reading;
+	int			sc_vhdrlen;
 };
 
 #ifdef	TUN_DEBUG
@@ -779,6 +787,23 @@ tun_dev_ioctl(dev_t dev, u_long cmd, void *data)
 		bcopy(data, sc->sc_ac.ac_enaddr,
 		    sizeof(sc->sc_ac.ac_enaddr));
 		break;
+	case TAPSVNETHDR:
+		if (*(int *)data != 0 &&
+		    *(int *)data != sizeof(struct virtio_net_hdr) &&
+		    *(int *)data != sizeof(struct virtio_net_hdr_legacy))
+			return (EINVAL);
+
+		sc->sc_vhdrlen = *(int *)data;
+
+		if (sc->sc_vhdrlen > 0) {
+			SET(sc->sc_if.if_capabilities, IFCAP_CSUM_TCPv4);
+			SET(sc->sc_if.if_capabilities, IFCAP_CSUM_UDPv4);
+			SET(sc->sc_if.if_capabilities, IFCAP_CSUM_TCPv6);
+			SET(sc->sc_if.if_capabilities, IFCAP_CSUM_TCPv6);
+			SET(sc->sc_if.if_capabilities, IFCAP_CSUM_UDPv6);
+		}
+
+		return (0);
 	default:
 		error = ENOTTY;
 		break;
@@ -828,6 +853,40 @@ tun_dev_read(dev_t dev, struct uio *uio, int ioflag)
 		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
 #endif
 
+	size_t len = ulmin(uio->uio_resid, sc->sc_vhdrlen);
+	if (len > 0) {
+		struct virtio_net_hdr vhdr;
+
+		bzero(&vhdr, sizeof(vhdr));
+
+		if (ISSET(m0->m_pkthdr.csum_flags, M_TCP_CSUM_OUT) ||
+		    ISSET(m0->m_pkthdr.csum_flags, M_UDP_CSUM_OUT)) {
+			struct ether_extracted ext;
+
+			ether_extract_headers(m0, &ext);
+			SET(vhdr.flags, VIRTIO_NET_HDR_F_NEEDS_CSUM);
+
+			vhdr.csum_start = sizeof(*ext.eh);
+#if NVLAN > 0
+			if (ext.evh)
+				vhdr.csum_start = sizeof(*ext.evh);
+#endif
+			if (ext.ip4 || ext.ip6)
+				vhdr.csum_start += ext.iphlen;
+
+			if (ext.tcp)
+				vhdr.csum_offset =
+				    offsetof(struct tcphdr, th_sum);
+			else if (ext.udp)
+				vhdr.csum_offset =
+				    offsetof(struct udphdr, uh_sum);
+		}
+
+		error = uiomove(&vhdr, len, uio);
+		if (error != 0)
+			goto free;
+	}
+
 	m = m0;
 	while (uio->uio_resid > 0) {
 		size_t len = ulmin(uio->uio_resid, m->m_len);
@@ -841,7 +900,7 @@ tun_dev_read(dev_t dev, struct uio *uio, int ioflag)
 		if (m == NULL)
 			break;
 	}
-
+free:
 	m_freem(m0);
 
 put:
@@ -870,6 +929,7 @@ tun_dev_write(dev_t dev, struct uio *uio, int ioflag, int align)
 	struct tun_softc	*sc;
 	struct ifnet		*ifp;
 	struct mbuf		*m0;
+	struct virtio_net_hdr	vhdr;
 	int			error = 0;
 	size_t			mlen;
 
@@ -905,10 +965,32 @@ tun_dev_write(dev_t dev, struct uio *uio, int ioflag, int align)
 	m0->m_pkthdr.len = m0->m_len = mlen;
 	m_adj(m0, align);
 
+	if (sc->sc_vhdrlen > 0) {
+		error = uiomove(&vhdr, sc->sc_vhdrlen, uio);
+		if (error != 0)
+			goto drop;
+	}
+
 	error = uiomove(mtod(m0, void *), m0->m_len, uio);
 	if (error != 0)
 		goto drop;
 
+	if (sc->sc_vhdrlen > 0) {
+		if (ISSET(vhdr.flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {
+			struct ether_extracted ext;
+
+			ether_extract_headers(m0, &ext);
+
+			if (ext.tcp) {
+				SET(m0->m_pkthdr.csum_flags, M_TCP_CSUM_IN_OK);
+				SET(m0->m_pkthdr.csum_flags, M_TCP_CSUM_OUT);
+			} else if (ext.udp) {
+				SET(m0->m_pkthdr.csum_flags, M_UDP_CSUM_IN_OK);
+				SET(m0->m_pkthdr.csum_flags, M_UDP_CSUM_OUT);
+			}
+		}
+	}
+
 	NET_LOCK();
 	if_vinput(ifp, m0);
 	NET_UNLOCK();
diff --git a/sys/net/if_tun.h b/sys/net/if_tun.h
index eea043e2596..0b83b0696f6 100644
--- a/sys/net/if_tun.h
+++ b/sys/net/if_tun.h
@@ -68,4 +68,7 @@ struct tuninfo {
 #define	TUNSDEBUG	_IOW('t', 94, int)
 #define	TUNGDEBUG	_IOR('t', 95, int)
 
+/* ioctl to set the virtio-net header size */
+#define TAPSVNETHDR	_IOW('t', 96, int)
+
 #endif /* _NET_IF_TUN_H_ */
diff --git a/usr.sbin/vmd/vionet.c b/usr.sbin/vmd/vionet.c
index f4bb1a9dc68..5e62bf7c6ab 100644
--- a/usr.sbin/vmd/vionet.c
+++ b/usr.sbin/vmd/vionet.c
@@ -18,6 +18,7 @@
  */
 #include <sys/socket.h>
 #include <sys/types.h>
+#include <sys/ioctl.h>
 
 #include <dev/pci/virtio_pcireg.h>
 #include <dev/pv/virtioreg.h>
@@ -102,13 +103,7 @@ vionet_main(int fd, int fd_vmm)
 	struct vm_create_params	*vcp;
 	ssize_t			 sz;
 	int			 ret;
-
-	/*
-	 * stdio - needed for read/write to disk fds and channels to the vm.
-	 * vmm + proc - needed to create shared vm mappings.
-	 */
-	if (pledge("stdio vmm proc", NULL) == -1)
-		fatal("pledge");
+	int			 vhdrlen = sizeof(struct virtio_net_hdr);
 
 	/* Initialize iovec arrays. */
 	memset(iov_rx, 0, sizeof(iov_rx));
@@ -133,6 +128,17 @@ vionet_main(int fd, int fd_vmm)
 	    ", vmm fd = %d", __func__, vionet->data_fd, dev.sync_fd,
 	    dev.async_fd, fd_vmm);
 
+	/* Activate virtio_net_hdr for tap(4) device. */
+	if (ioctl(vionet->data_fd, TAPSVNETHDR, &vhdrlen) == -1)
+		fatal("%s: TAPSVNETHDR option on tap(4) failed", __func__);
+
+	/*
+	 * stdio - needed for read/write to disk fds and channels to the vm.
+	 * vmm + proc - needed to create shared vm mappings.
+	 */
+	if (pledge("stdio vmm proc", NULL) == -1)
+		fatal("pledge");
+
 	/* Receive our vm information from the vm process. */
 	memset(&vm, 0, sizeof(vm));
 	sz = atomicio(read, dev.sync_fd, &vm, sizeof(vm));
@@ -413,6 +419,7 @@ vionet_rx(struct vionet_dev *dev, int fd)
 
 		iov = &iov_rx[0];
 		iov_cnt = 1;
+		chain_len = 0;
 
 		/*
 		 * First descriptor should be at least as large as the
@@ -425,22 +432,9 @@ vionet_rx(struct vionet_dev *dev, int fd)
 			goto reset;
 		}
 
-		/*
-		 * Insert the virtio_net_hdr and adjust len/base. We do the
-		 * pointer math here before it's a void*.
-		 */
 		iov->iov_base = hvaddr_mem(desc->addr, iov->iov_len);
 		if (iov->iov_base == NULL)
 			goto reset;
-		memset(iov->iov_base, 0, sizeof(struct virtio_net_hdr));
-
-		/* Tweak the iovec to account for the virtio_net_hdr. */
-		iov->iov_len -= sizeof(struct virtio_net_hdr);
-		iov->iov_base = hvaddr_mem(desc->addr +
-		    sizeof(struct virtio_net_hdr), iov->iov_len);
-		if (iov->iov_base == NULL)
-			goto reset;
-		chain_len = iov->iov_len;
 
 		/*
 		 * Walk the remaining chain and collect remaining addresses
@@ -491,12 +485,6 @@ vionet_rx(struct vionet_dev *dev, int fd)
 		if (sz == 0)	/* No packets, so bail out for now. */
 			break;
 
-		/*
-		 * Account for the prefixed header since it wasn't included
-		 * in the copy or zerocopy operations.
-		 */
-		sz += sizeof(struct virtio_net_hdr);
-
 		/* Mark our buffers as used. */
 		used->ring[used->idx & VIONET_QUEUE_MASK].id = hdr_idx;
 		used->ring[used->idx & VIONET_QUEUE_MASK].len = sz;
@@ -766,17 +754,15 @@ vionet_tx(struct virtio_dev *dev)
 		if (iov->iov_len < sizeof(struct virtio_net_hdr)) {
 			log_warnx("%s: invalid descriptor length", __func__);
 			goto reset;
-		} else if (iov->iov_len > sizeof(struct virtio_net_hdr)) {
-			/* Chop off the virtio header, leaving packet data. */
-			iov->iov_len -= sizeof(struct virtio_net_hdr);
-			chain_len += iov->iov_len;
-			iov->iov_base = hvaddr_mem(desc->addr +
-			    sizeof(struct virtio_net_hdr), iov->iov_len);
-			if (iov->iov_base == NULL)
-				goto reset;
-			iov_cnt++;
 		}
 
+		/* Handel the first descriptor. */
+		chain_len += iov->iov_len;
+		iov->iov_base = hvaddr_mem(desc->addr, iov->iov_len);
+		if (iov->iov_base == NULL)
+			goto reset;
+		iov_cnt++;
+
 		/*
 		 * Walk the chain and collect remaining addresses and lengths.
 		 */
@@ -850,7 +836,6 @@ vionet_tx(struct virtio_dev *dev)
 			log_warn("%s", __func__);
 			goto reset;
 		}
-		sz += sizeof(struct virtio_net_hdr);
 drop:
 		used->ring[used->idx & VIONET_QUEUE_MASK].id = hdr_idx;
 		used->ring[used->idx & VIONET_QUEUE_MASK].len = sz;
diff --git a/usr.sbin/vmd/virtio.c b/usr.sbin/vmd/virtio.c
index 536c7733a7a..d354148aff1 100644
--- a/usr.sbin/vmd/virtio.c
+++ b/usr.sbin/vmd/virtio.c
@@ -61,6 +61,8 @@ SLIST_HEAD(virtio_dev_head, virtio_dev) virtio_devs;
 
 #define MAXPHYS	(64 * 1024)	/* max raw I/O transfer size */
 
+#define VIRTIO_NET_F_CSUM	(1<<0)
+#define VIRTIO_NET_F_GUEST_CSUM	(1<<1)
 #define VIRTIO_NET_F_MAC	(1<<5)
 
 #define VMMCI_F_TIMESYNC	(1<<0)
@@ -586,6 +588,10 @@ virtio_init(struct vmd_vm *vm, int child_cdrom,
 			memcpy(&dev->vionet.mac, &vmc->vmc_macs[i], 6);
 			dev->vionet.cfg.device_feature = VIRTIO_NET_F_MAC;
 
+			/* enable checksum offlaoding */
+			dev->vionet.cfg.device_feature |= VIRTIO_NET_F_CSUM |
+			    VIRTIO_NET_F_GUEST_CSUM;
+
 			dev->vionet.lockedmac =
 			    vmc->vmc_ifflags[i] & VMIFF_LOCKED ? 1 : 0;
 			dev->vionet.local =

